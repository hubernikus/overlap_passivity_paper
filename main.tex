\documentclass[conference]{IEEEtran}
%\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
%% \usepackage{cite}
\usepackage{hyperref}
\usepackage{svg}

\usepackage{amsmath,amssymb,amsfonts}
\usepackage{amsthm} % Allows usage of '\theoremstyle'

\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{subcaption}
\usepackage[font=small,labelfont=bf]{caption} % small fontsize in caption

%% \def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
%%     T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\usepackage[
    backend=biber,
    style=ieee,
    sorting=none,
    %% citestyle=authoryear
    ]{biblatex}
\addbibresource{bibliography.bib}

\usepackage[normalem]{ulem}


\begin{document}
\newcommand{\vect}[1]{\boldsymbol{#1}}
\newcommand{\vecs}[1]{\boldsymbol{#1}}
\newcommand{\matr}[1]{\boldsymbol{#1}}
\newcommand{\matd}[1]{\mathcal{#1}}

\newcommand{\dotprod}[2]{\left\langle {#1}, \, {#2} \right\rangle}
\newcommand{\normdotprod}[2]{\frac{\left\langle #1, \, #2 \right\rangle}{\| #1 \| \, \| #2 \|}}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[section]
\newtheorem{lemma}{Lemma}[section]
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]


\title{Obstacle Aware Passive Control for Dynamical Systems}
\author{
  \IEEEauthorblockN{Lukas Huber, Trinca Thibaud, Jean-Jacques Slotine, Aude Billard}
}

\maketitle
\thispagestyle{plain}
\pagestyle{plain}

\begin{abstract}
Recent work on dynamical systems (DS) has enabled new ways of robot control. DS can be learned with various methods and often modified so that all points in space converge to the attractor, making the system more robust to noise or disturbances.
One can use DS modulation to avoid obstacles, with solid guarantees of impenetrability consistently. To transfer from DS velocity control to torque control, passive control theory is a powerful method to accurately track the desired speed while having the freedom to demonstrate compliant behavior.
In this work, we present a method that extends the concept of passivity.
The method maintains compliant behavior away from obstacles but increases the stiffness of the control when approaching one of them, allowing the robot to be aware of its environment.
The proof of concept was tested in a simulation in Python. The robot shows excellent tracking performance and successfully rejects disturbances that would have led to a collision with an obstacle. 
\end{abstract}

\begin{IEEEkeywords}
Obstacle avoidance, dynamical systems, passivity, human-robot interaction
\end{IEEEkeywords}

\input{input/introduction}
\input{input/preliminaries}




\subsection{Problem Statement}
We will make the following assumptions about $\vecs f(\vecs\xi)$:
\begin{enumerate}
    \item $ \vecs f(\vecs\xi)$ is defined for all reachable states $\vecs\xi$ and is continuous.
    %% \item $\vecs f(\vecs\xi)$ has a single equilibrium point $\vecs\xi^a$, such that $\{ \vecs \xi : \vecs f(\vecs \xi) = \vecs 0 \} = \{ \vecs\xi^a \}$. 
    \item $\vecs f(\vecs\xi)$ is bounded, i.e., there exists a constant $v^{\mathrm{max}} \in \mathbb{R}$ such that $\| \vecs f(\vecs\xi) \| \leq v^{\mathrm{max}} \;\; \forall \, \vecs \xi \in \mathbb{R}^N$
\end{enumerate}

Furthermore, we require that all the trajectories are collision-free,: 
\begin{enumerate}
  \setcounter{enumi}{3}
  \item $\vecs{n_o}(\vecs\xi)^T \vecs f(\vecs\xi) \geq 0$ as $\Gamma_o \rightarrow 1 
  \quad \forall o = 1 .. N^{\mathrm{obs}}$
\end{enumerate}
with $\vecs n_o (\vecs \xi)$ and $d_o$ the normal and the distance of the $i$-th obstacle, see Section~\ref{sec:obstacle_normals}. 
Note that the DS obtained after DSM as described in \eqref{eq:modulated} fulfills these conditions if initial DS $\vecs f^I$ is continuous, bounded, and has a sing convergence to the attractor.

We require that the initial dynamics are collision-free

\section{Obstacle Aware Passivity} \label{sec:obstacle_aware_passivity}
The controller is inspired by the design proposed \cite{kronander2015passive}.
% The method of \cite{kronander2015passive} presented above allows for being stiff in the direction of motion and compliant in the perpendicular directions.

However, this method does not consider obstacles when computing $\matd D$. Unfortunately, if a disturbance happens to push the robot into an obstacle that is perpendicular to the direction of motion, it will not be damped. This could lead to the robot crashing into the obstacle. In those cases, we would like to increase the stiffness of the control and dampen the disturbance.

We propose a novel controller, which ensures passivity as defined in \eqref{eq:control_command} but adapts the damping matrix given in \eqref{D_matrix_shaping} based on the desired dynamics $\dot{\vecs \xi}$ and obstacles in the surrounding. 

The idea is that the matrix $\matd Q$ smoothly transitions from an orthonormal basis aligned to the DS direction (traditional passive control) to a basis aligned with the normal of the obstacle when approaching one.

\subsection{Averaged Normal Direction} \label{sec:obstacle_normals}
Let us define the unit normal $\vecs{n_o} (\vecs\xi)$  pointing away from the obstacle $o \in \{1,  ..,  N^{\mathrm{obs}} \}$, the averaged normal can be evaluated as:
% Let the resultant normal of the obstacles $\vecs n(\vecs\xi)$ be expressed as:
%% \begin{equation}
%%     \vecs n(\vecs\xi) = \frac{\sum_{i=1}^{M} \frac{\vecs{n_i}(\vecs\xi)}{d_i(\vecs\xi) + \epsilon} }{\sum_{i=1}^{M} \frac{1}{d_i(\vecs\xi) + \epsilon}}
%% \end{equation}
%% for a small $\epsilon$.
\begin{equation}
  \vecs n(\vecs\xi) = \sum_{o=1}^{N^{\mathrm{obs}}} \vecs{n_o}(\vecs\xi)
  \frac{1 / (\Gamma_o(\vecs \xi) - 1)}{\sum_{o=1}^{N^\mathrm{obs}} 1 / (\Gamma_o(\vecs \xi) - 1)}
  %% \;\; , \quad 
  %% w^\Gamma_o(\xi) =  
\end{equation}
The resultant normal $\vecs n(\vecs \xi)$ is a weighted linear combination of the obstacles' normals, giving more importance to closer obstacles.
Further, the resultant converges to an obstacle normal as we converge towards it, i.e., $\lim_{\Gamma_o(\vecs \xi) \rightarrow 1} \vecs n(\vecs \xi) = \vecs n_o(\vecs \xi)$.
% The advantage of this function is that $\vecs n$ converges to $ \vecs n_i$ as the robot gets closer to obstacle $i$. An example is provided in Fig.~\ref{resultant_normal}.\\
Note that the normal is a zero-vector when two obstacles oppose each other. This case will be further discussed in the next section.

\begin{figure}
\centerline{\includegraphics[width=0.5\textwidth]{figures/normal_and_gamma_field_visualization}}
\caption{The $\Gamma$-field for the two obstacles is used to evaluate the averaged normal $\vecs n$ (red arrow). 
Both parameters must ensure the motion follows the avoidance dynamics (gray) towards the attractor (black star) while remaining compliant.}
\label{fig:resultant_normal}
\end{figure}

% There could be cases where the resultant normal is not defined (due to $\vecs{n_i}$'s canceling each other). A solution to this issue is proposed in \ref{limit_cases}.

\subsection{Danger Weight}
Let us define the danger weight function $w(\vecs\xi) \in [0, 1]$ based on the distance to obstacles:
\begin{equation}
  \begin{split}
w(\vecs\xi) =
\max \left(0,  \frac{\Gamma^{\mathrm{crit}} - \Gamma(\vecs\xi)}{\Gamma^{\mathrm{crit}} - 1} \right) \| \vecs n(\vecs \xi) \| \\
\text{with} \quad
\Gamma(\vecs\xi) = \min_{o = 1..N^{\mathrm{obs}}} \Gamma_o(\vecs\xi)
\label{eq:weight_function}
\end{split}
\end{equation}
%% \begin{equation}
%%   %% \Gamma(\vecs\xi) = \min_{o \in \{1, .., N^{\mathrm{obs}} \}} \Gamma_o(\vecs\xi)
%%   \Gamma(\vecs\xi) = \min_{o = 1..N^{\mathrm{obs}}} \Gamma_o(\vecs\xi)
%% \end{equation}
The critical distance $\Gamma^{\mathrm{crit}} \in \mathbb{R}$ defines the distance where the system behaves stiffly towards the obstacle.
Note that $w(\vecs \xi) = 0$ far away from obstacles, and $w(\vecs \xi) = 1$ as it approaches a boundary.

\subsection{Damping Matrix}
While most robotics systems is moving in dimensions $d = 3$, the development in this section can be applied to $d \geq 2$.
% In the following sections, we will consider $N = 3$, which limits the control to a 3-dimensional (Cartesian space in our case). However, the theory presented can easily be extrapolated to work in greater dimensions.
% \subsubsection{Combinaison of the damping matrices}
%% Let us now combine the two matrices:
The desired damping matrix has two goals: it should maintain and follow the desired DS, and at the same time, it has to ensure collision avoidance with obstacles. We define it as a linear combination that achieves these two parts:
\begin{equation}
    \matd D(\vecs\xi) = \left(1 - w(\vecs\xi) \right) {\matd D^{DS}}(\vecs\xi) + w(\vecs\xi)  {\matd D^{\mathrm{obs}}}(\vecs\xi) \label{eq:damping_summation}
\end{equation}
Away from any obstacle, the behavior is fully controlled by $\vecs {D_{DS}}(\vecs\xi)$, and when approaching one, the damping matrix smoothly shifts to also stiffen the control against the obstacle. 
Note that as ${\matd D^{DS}}(\vecs\xi)$ and $\matd {D^{\mathrm{obs}}}(\vecs\xi)$ are positive semi-definite matrices, thus $\matd {D}(\vecs\xi)$ is positive semi-definite, too.


\subsubsection{Dynamic System Following}
The damping matrix, which achieves the dynamical system following $\matd D^{DS}$, is designed as presented in Section~\ref{sec:trad_passive}, following the theory of \cite{kronander2015passive}. $\matd D^{DS}$ has high stiffness in the direction of the desired velocity $\dot{\vecs \xi}$, but is compliant perpendicular to it.

\begin{equation}
  \begin{split}
  s_d^{DS} =
  \begin{cases}
    s^{DS} & d = 1 \\
    w^p s^{\mathrm{obs}} + (1- w^p) s^s & d \geq 2 
  \end{cases} \quad d = 1 .. N\\
  \text{with} \quad
  %w^p = \min \left(1,  \| \vecs n(\vecs \xi) \|^2 + \left(\frac{\Gamma(\vecs \xi) -1}{\Gamma^{\mathrm{crit}} - 1}\right) ^2 \right)
   w^p = \min \left(1,  \| \vecs n(\vecs \xi) \|^2 + \left(\frac{\Gamma^{\mathrm{crit}} -\Gamma(\vecs \xi)}{\Gamma^{\mathrm{crit}} - 1}\right) ^2 \right)
  \end{split}
\end{equation}
where the ds-damping $s^{DS} \in \mathbb{R}$, obstacle-damping $s^{\mathrm{obs}} \in \mathbb{R}$, and the compliant-damping $s^c \in \mathbb{R}$ are user-defined values which define the behavior of the passive-controller.


\subsubsection{Obstacle Repulsion}
Let us define $\vecs q^{DS}_1 (\vecs\xi) = \dot{\vecs \xi} / \lVert \dot{\vecs \xi}\rVert$ the vector aligned to the direction of desired motion and $\vecs q_1^{\mathrm{obs}}(\vecs\xi) =  \vecs n(\vecs\xi) / \lVert\vecs n(\vecs\xi)\rVert$ the vector aligned to the obstacles normal.
In the following, we will omit the dependency of the vectors on $\vecs\xi$ for readability purposes.

% We will now define $\vecs{e_{3,obs}} = \vecs{e_{1,obs}} \times \vecs {e_{1,DS}}$ and $\vecs{e_{2,obs}} = \vecs{e_{3,obs}} \times \vecs {e_{1,obs}}$. This defines the orthonormal basis related to the obstacle, with its second vector being the closest to the DS-following vector $\vecs{e_{1,DS}}$.
\begin{equation}
  \vecs q_2^{\mathrm{obs}} = \frac{\hat{\vecs q}_2^{\mathrm{obs}}}{\| \hat{\vecs q}_2^{\mathrm{obs}} \|}
  \quad
  \hat{\vecs q}_2^{\mathrm{obs}} = \vecs q_1^{DS} - \vecs q_1^{\mathrm{obs}} p \quad  \forall \vecs \xi : | p | < 1
\end{equation}
where the object weight is given as $p = \dotprod{\vecs q_1^{\mathrm{obs}}}{\vecs q_1^{DS}}$
The remaining vectors $\vecs q_i^{\mathrm{obs}}, i = 3, .., N$ are set to be orthonormal. For the case that $| p | = 1$, the second basis $\vecs q_2^{\mathrm{obs}}$ is set to be any orthonormal vector. 
Consequently, we define the damping values to ensure smoothness:
\begin{equation}
  s_d^{\mathrm{obs}} =
  \begin{cases}
    s^{\mathrm{obs}} & d = 1 \\
    | p | s^c + (1 - | p |) s^{DS} & d = 2 \\
    s^c & d \geq 3 
  \end{cases}
  \quad d = 1 .. N\
\end{equation}

\begin{figure}
  \center
  % \includegraphics[width=0.6\columnwidth]{figures/damping_basis_construction}
\caption{The damping matrix enforcing DS following $\matd{D}^{\mathrm{DS}}$ has the first basis vector $\vect q_1^{\mathrm{DS}}$ which follows the avoidance dynamics $\dot{\vecs \xi}$ and damping to enforce collision avoidance with $\matd{D}^{\mathrm{obs}}$ uses the normal $\vect n(\vecs \xi)$ to construct the first direction of the decomposition basis $\vect q^{\mathrm{obs}}_1$.}
\label{fig:damping_basis_construction}
%% \label{fig_basis_3D_DS_obs}
\end{figure}

% Let the matrix $\vecs{Q_{obs}}(\vecs\xi) \in \mathbb{R}^{3\times 3}$ be the matrix whose columns are formed by the orthonormal basis $\vecs {e_{1,obs}}, \vecs {e_{2,obs}}, \vecs{e_{3,obs}}$.\\

% Moreover, let the diagonal matrix $\vecs\Lambda(\vecs\xi) \in \mathbb{R}^{N\times N}$ be the matrix whose diagonal is $\lambda_1(\vecs\xi), \lambda_2(\vecs\xi)$ and $ \lambda_3$. Each eigenvalue corresponds to the damping coefficient along its respective direction given by the vectors.

% Finally we construct $\vecs {D_{obs}}(\vecs\xi)$ as in \eqref{D_matrix_shaping}. Note that the columns of $\vecs Q(\vecs\xi)$ always form an orthonormal basis and that $\lambda_i \geq 0$ $\forall i=1,...,N$. $\vecs D(\vecs\xi)$ is thus a positive semi-definite matrix.

%In the general case, we would have $\lambda_1 = \lambda_{obs}$  corresponding to the damping coefficients associated with moving into an obstacle, $\lambda_2 = \lambda_{DS}$ the tracking stiffness and $\lambda_3 = \lambda_{perp}$ is the coefficient responsible for being compliant in the remaining direction.


% First, we want the damping coefficient $\lambda_2(\vecs\xi)$ to be equal to $\lambda_{DS}$ only when the DS and the obstacle normal are perpendicular. Likewise, we want this coefficient to be equal to $\lambda_{perp}$ when the normal and the DS are collinear. We thus define: 
% \begin{equation}
%     \lambda_2' = \lambda_{perp} \lvert \vecs {e_{1,obs}}^T \vecs {e_{1,DS}} \rvert + \lambda_{DS} (1 - \lvert \vecs {e_{1,obs}}^T \vecs {e_{1,DS}}\rvert)
% \end{equation}
% This also solves the case where $\vecs{e_{1,DS}}$ and $\vecs{e_{2,obs}}$ are perfectly collinear. In this case, the matrix $Q(\xi)$ would become discontinuous, making $D_{obs}$ also discontinuous. This definition of $\lambda_2'$ is designed to converge to the same value as $\lambda_3$, which keeps $D_obs$ always defined.

% The damping coefficient $\lambda_1$ could stay constant. However, we introduce a design that allows for more compliance in XX section.

%% \subsection{Special cases} \label{limit_cases}
%% \subsubsection{Obstacle normal undefined}
%% It could happen that $\vecs n(\vecs \xi)$ is undefined (zero-vector) due to normals of many obstacles canceling each other. To solve this issue, we use smooth step functions. These functions, $H_{a,b}(x)$ and $H_{a,b}^-(x)$, take a value of 0 before $a$ and 1 after $b$, and inversely. They are properly defined in the appendix.
%% As $\lVert \vecs n(\vecs \xi) \rVert \rightarrow 0$, we modify the weight $w$ and make it tend to $0$. This has the effect of smoothly returning to $\vecs D = \vecs{D_{DS}}$, the traditional passive control damping matrix. An implementation is proposed here:  
%% \begin{equation}
%% \label{weight_vanish_norm}
%%     w' = w H_{0, \epsilon}(\lVert \vecs n(\vecs \xi) \rVert)
%% \end{equation}
%% with $\epsilon = 0.01$ chosen in practice.\\
%% Fig.~\ref{fig_smooth_w} shows how this affects the weight function.

%% \begin{figure}
%% \centerline{\includegraphics[width=0.5\textwidth]{figures/smooth_step_weight.png}}
%% \caption{Function used to modify the weight when $\lVert \vecs n(\vecs \xi) \rVert \rightarrow 0$. As an example, we took $w = 0.5$.}
%% \label{fig_smooth_w}
%% \end{figure}

\subsection{Damping Only Towards Obstacle} \label{sec:damping_only_toward}
To reject only the disturbances that push the agent against the obstacle and allow compliance in the perpendicular direction away from the obstacle, we have added a new feature. Suppose the robot is currently moving away from the obstacle ($\vecs{\dot\xi}^T \vecs n(\vecs\xi) > 0$). In that case, the value of $\lambda_1$ gets overwritten with $\lambda_{perp}$, the desired damping coefficient for compliance in the orthogonal direction. This ensures that only the disturbances pushing the agent into the obstacle are damped. \\

%% With this feature active, the damping matrix also depends on the velocity. However, as $\vecs{\dot\xi}^T \vecs n(\vecs\xi)$ changes of sign, $\lambda_2$ changes abruptly. This causes $\frac{\partial}{\partial \vecs{\dot\xi}} \vecs D(\vecs{\dot\xi}, \vecs\xi)$ to be infinite at some places, which loses continuity. This can be avoided using again the smooth step functions $H_{a,b}(x)$ and $H_{a,b}^-(x)$. We define,
%% \begin{equation}
%%     \lambda_1' = \lambda_{obs} H_{0,\epsilon}^-(\vecs{\dot\xi}^T \vecs n(\vecs\xi)) + \lambda_{perp} H_{0, \epsilon}(\vecs{\dot\xi}^T \vecs n(\vecs\xi))
%% \end{equation}
%% which is now smoothly defined. We used $\epsilon = 0.01$ in practice.\\

\begin{equation}
  s_1^{DS} =
  \begin{cases}
    s^{DS} & \text{if} \;\; \vecs{\dot \xi}^T \vecs n(\vect \xi) > 0 \\
    0 & \text{otherwise}
  \end{cases}
\end{equation}

Note that in the rest of this work, we will continue referring to $\matd{D}(\vecs{\dot\xi}, \vecs\xi)$ as $\matd D(\vecs\xi)$.


\subsection{Damping Parameter Design}
The damping values are chosen such that $s^{\mathrm{obs}}$ is high to ensure a big damping towards the obstacle. $s^{DS}$ should have a medium-high value to ensure motion in the desired direction. And finally, $s^{c}$ is chosen smaller to allow compliance in all other directions. Thus, we have:
\begin{equation}
s^{\mathrm{obs}} > s^{DS} \gg s^{c} > 0
\end{equation}

% here the subsection with proof of lukas
\input{input/passivity_proof}

\section{Collision Avoidance} \label{sec:collision_avoidance}
\subsection{Inertia Drift}
Let us assume that have strong damping in the direction of the obstacle, i.e., $s^{\mathrm{obs}} / m_i \gg 1$, where $m_i$ with $i = 1, .., N$ represent the eigenvalues of the mass matrix $\matd{M}$. 


\subsection{Disturbance Repulsion}
Let us assume a disturbance impact at time $t_0$, which results in the robot having an impact velocity of $\vecs{\dot \xi} = \vect v^I$, which is pointing towards the obstacle. The impact velocity is much larger than the robot's initial velocity. Thus the latter is neglected, and the obstacle is approximated as locally flat and the velocity locally constant (see Fig.~\ref{fig:collision_avoidance}). Furthermore, we assume to be close to the robot, i.e., $\Gamma(\vecs \xi) \approx 1$, hence the $w(\vecs \xi) \approx 1$, and the stiffness in the direction of the obstacle is approximated as $s^{\mathrm{obs}}$.
No further impact forces are applied after the initial impact is absorbed. The Coriolis effect is neglected in the short time frame.

The velocity with the controller can be analyzed as follows:
\begin{equation}
    \vecs{\dot \xi} = \int \vecs{\ddot \xi} \, dt = \int \matd{D} \matd{M}^{-1} \left( \vecs{\dot \xi} - \vecs f(\vecs \xi) \right) \, dt
\end{equation}

Let us analyze when the decoupled velocity along the normal reaches zero:
\begin{equation}
    \vecs{\dot \xi} = \int \frac{s^{\mathrm{obs}}}{m} \vecs{\dot \xi} \, dt = \frac{s^{\mathrm{obs}}}{m} \vecs{\xi} + \vecs v^I \label{eq:velocity_with_control}
\end{equation}
The velocity along the normal reaches zero at position, i.e., 
\begin{equation}
    \| \vecs{\dot \xi} \| = 0
    \quad \Rightarrow \quad
    \|\vecs{\xi} \| = \| \vecs v^I \| {m} / {s^{\mathrm{obs}}} 
\end{equation}

\begin{lemma}

\end{lemma}

\begin{proof}
The statement follows directly from \eqref{eq:velocity_with_control}.
\end{proof}

\subsection{Disturbance Repulsion with Force Limit}
Robotic systems have a maximum force that can be exerted based on the motors and their geometry, $\tau_c^{\mathrm{max}} \in \mathbb{R}_{>0}$. Note that this maximum might be state dependent.

Let  us assume strong damping concerning the maximum force, i.e., $s^{\mathrm{obs}} / \tau_c^{\mathrm{max}} \gg 1$, hence we can assume that the magnitude of the obstacle repulsive force is equal to the maximum force close to the obstacle. Hence, the maximum disturbance.

\subsection{Practical Considerations}
As described in \cite{huber2022avoiding, huber2023avoidance}, the avoidance velocity when approaching an obstacle can be directed along the normal of the obstacle to point away from the surface when reaching the obstacle and inside. This allows improved recovery, for scenarios such as those presented.

\begin{figure}
\centering
\begin{subfigure}{0.99\columnwidth}
  \centerline{\includegraphics[width=\textwidth]{figures/parallel_avoidance_obstacle}}
  \caption{Parallel to surface velocity}
  \label{fig:disturbance_with_parallel_velocity}
\end{subfigure}
\begin{subfigure}{0.5\columnwidth}
  %% \centerline{\includegraphics[width=\textwidth]{}}
  \caption{Repulsive surface velocity}
  \label{fig:disturbance_with_repulsive_velocity}
\end{subfigure}
\caption{Comparison of the two control methods}
\label{fig:disturbance_rejection_schematics}
\end{figure}

\section{Discrete Time Avoidance}
For the algorithm applied in discrete time, as will be the case for any digital controller, the evolution of the velocity is given by:
\begin{equation}
    \vect v_{t + 1} = \matr{D} \left( \vect v^{\mathrm{des}}_t - \vect v_t \right)
\end{equation}


\input{input/results}
 


% \appendix
% \section{Appendix}
% \label{Appendix}

\renewcommand*{\bibfont}{\footnotesize}
\printbibliography

\end{document}
